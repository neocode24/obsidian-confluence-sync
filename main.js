/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ConfluenceSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/ui/settings/SettingsTab.ts
var import_obsidian2 = require("obsidian");

// src/api/ConfluenceClient.ts
var import_obsidian = require("obsidian");
var http = __toESM(require("http"));
var crypto = __toESM(require("crypto"));
var MCPConnectionError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "MCPConnectionError";
  }
};
var OAuthError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "OAuthError";
  }
};
var DEFAULT_OAUTH_CONFIG = {
  redirectUri: "http://localhost:8080/callback",
  scope: "read:confluence-content.all write:confluence-content read:confluence-space.summary offline_access",
  authorizationUrl: "https://auth.atlassian.com/authorize",
  tokenUrl: "https://auth.atlassian.com/oauth/token",
  resourcesUrl: "https://api.atlassian.com/oauth/token/accessible-resources"
};
var ConfluenceClient = class {
  constructor(oauthConfig) {
    this.currentTenant = null;
    this.localServer = null;
    this.oauthConfig = oauthConfig;
  }
  /**
   * Initialize Confluence client
   */
  async initialize(tenantConfig) {
    this.currentTenant = tenantConfig;
    console.log(`Confluence client initialized for ${tenantConfig.url}`);
  }
  /**
   * Initiate OAuth 2.0 authorization flow
   */
  async initiateOAuth() {
    if (!this.currentTenant) {
      throw new MCPConnectionError("Tenant\uAC00 \uCD08\uAE30\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
    }
    try {
      const state = crypto.randomBytes(16).toString("hex");
      const authUrl = new URL(DEFAULT_OAUTH_CONFIG.authorizationUrl);
      authUrl.searchParams.set("audience", "api.atlassian.com");
      authUrl.searchParams.set("client_id", this.oauthConfig.clientId);
      authUrl.searchParams.set("scope", this.oauthConfig.scope);
      authUrl.searchParams.set("redirect_uri", this.oauthConfig.redirectUri);
      authUrl.searchParams.set("state", state);
      authUrl.searchParams.set("response_type", "code");
      authUrl.searchParams.set("prompt", "consent");
      await this.startCallbackServer(state);
      window.open(authUrl.toString(), "_blank");
      new import_obsidian.Notice("\uBE0C\uB77C\uC6B0\uC800\uC5D0\uC11C Confluence \uC778\uC99D\uC744 \uC9C4\uD589\uD574\uC8FC\uC138\uC694.");
    } catch (error) {
      console.error("OAuth flow failed:", error);
      throw new OAuthError(
        `OAuth \uC778\uC99D \uC2E4\uD328: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Start local HTTP server to receive OAuth callback
   */
  async startCallbackServer(expectedState) {
    return new Promise((resolve, reject) => {
      this.localServer = http.createServer(async (req, res) => {
        var _a;
        if (!((_a = req.url) == null ? void 0 : _a.startsWith("/callback"))) {
          res.writeHead(404);
          res.end("Not Found");
          return;
        }
        const url = new URL(req.url, `http://localhost:8080`);
        const code = url.searchParams.get("code");
        const state = url.searchParams.get("state");
        if (state !== expectedState) {
          res.writeHead(400);
          res.end("Invalid state parameter");
          this.stopCallbackServer();
          reject(new OAuthError("State mismatch"));
          return;
        }
        if (!code) {
          res.writeHead(400);
          res.end("No authorization code received");
          this.stopCallbackServer();
          reject(new OAuthError("No authorization code"));
          return;
        }
        try {
          await this.exchangeCodeForTokens(code);
          res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
          res.end('<html><head><meta charset="utf-8"></head><body><h1>\u2705 \uC778\uC99D \uC131\uACF5!</h1><p>Obsidian\uC73C\uB85C \uB3CC\uC544\uAC00\uC138\uC694.</p></body></html>');
          this.stopCallbackServer();
          resolve();
        } catch (error) {
          res.writeHead(500, { "Content-Type": "text/html; charset=utf-8" });
          res.end('<html><head><meta charset="utf-8"></head><body><h1>\u274C \uC778\uC99D \uC2E4\uD328</h1><p>\uC5D0\uB7EC: ' + (error instanceof Error ? error.message : "Unknown error") + "</p></body></html>");
          this.stopCallbackServer();
          reject(error);
        }
      });
      this.localServer.listen(8080, () => {
        console.log("OAuth callback server started on port 8080");
        resolve();
      });
      this.localServer.on("error", (error) => {
        reject(new OAuthError(`Failed to start callback server: ${error.message}`));
      });
    });
  }
  /**
   * Exchange authorization code for access/refresh tokens
   */
  async exchangeCodeForTokens(code) {
    const response = await (0, import_obsidian.requestUrl)({
      url: DEFAULT_OAUTH_CONFIG.tokenUrl,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        grant_type: "authorization_code",
        client_id: this.oauthConfig.clientId,
        client_secret: this.oauthConfig.clientSecret,
        code,
        redirect_uri: this.oauthConfig.redirectUri
      })
    });
    const tokens = response.json;
    const cloudId = await this.getCloudId(tokens.access_token);
    if (this.currentTenant) {
      this.currentTenant.oauthToken = {
        accessToken: tokens.access_token,
        refreshToken: tokens.refresh_token,
        expiresAt: Date.now() + tokens.expires_in * 1e3
      };
      this.currentTenant.cloudId = cloudId;
    }
    console.log("OAuth tokens obtained successfully");
    new import_obsidian.Notice("\u2705 Confluence \uC778\uC99D \uC131\uACF5!");
  }
  /**
   * Get Atlassian Cloud ID for the authenticated user
   */
  async getCloudId(accessToken) {
    const response = await (0, import_obsidian.requestUrl)({
      url: DEFAULT_OAUTH_CONFIG.resourcesUrl,
      method: "GET",
      headers: {
        "Authorization": `Bearer ${accessToken}`,
        "Accept": "application/json"
      }
    });
    const resources = response.json;
    if (!resources || resources.length === 0) {
      throw new OAuthError("No accessible Atlassian resources found");
    }
    return resources[0].id;
  }
  /**
   * Stop OAuth callback server
   */
  stopCallbackServer() {
    if (this.localServer) {
      this.localServer.close();
      this.localServer = null;
      console.log("OAuth callback server stopped");
    }
  }
  /**
   * Check if client is connected and authenticated
   */
  isConnected() {
    return this.currentTenant !== null && this.currentTenant.oauthToken !== void 0 && this.currentTenant.oauthToken.expiresAt > Date.now();
  }
  /**
   * Get current tenant configuration
   */
  getCurrentTenant() {
    return this.currentTenant;
  }
  /**
   * Get access token (refresh if needed)
   */
  async getAccessToken() {
    var _a;
    if (!((_a = this.currentTenant) == null ? void 0 : _a.oauthToken)) {
      throw new OAuthError("Not authenticated");
    }
    if (this.currentTenant.oauthToken.expiresAt <= Date.now()) {
      await this.refreshAccessToken();
    }
    return this.currentTenant.oauthToken.accessToken;
  }
  /**
   * Refresh access token using refresh token
   */
  async refreshAccessToken() {
    var _a, _b;
    if (!((_b = (_a = this.currentTenant) == null ? void 0 : _a.oauthToken) == null ? void 0 : _b.refreshToken)) {
      throw new OAuthError("No refresh token available");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: DEFAULT_OAUTH_CONFIG.tokenUrl,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        grant_type: "refresh_token",
        client_id: this.oauthConfig.clientId,
        client_secret: this.oauthConfig.clientSecret,
        refresh_token: this.currentTenant.oauthToken.refreshToken
      })
    });
    const tokens = response.json;
    this.currentTenant.oauthToken = {
      accessToken: tokens.access_token,
      refreshToken: tokens.refresh_token || this.currentTenant.oauthToken.refreshToken,
      expiresAt: Date.now() + tokens.expires_in * 1e3
    };
    console.log("Access token refreshed successfully");
  }
  /**
   * Disconnect and clear state
   */
  async disconnect() {
    this.stopCallbackServer();
    this.currentTenant = null;
  }
};

// src/ui/settings/SettingsTab.ts
var ConfluenceSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.confluenceClient = null;
    this.plugin = plugin;
  }
  initializeClient() {
    var _a, _b;
    if (!((_a = this.plugin.settings.oauthConfig) == null ? void 0 : _a.clientId) || !((_b = this.plugin.settings.oauthConfig) == null ? void 0 : _b.clientSecret)) {
      return;
    }
    this.confluenceClient = new ConfluenceClient(this.plugin.settings.oauthConfig);
  }
  display() {
    var _a, _b;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Confluence Sync \uC124\uC815" });
    if (!this.confluenceClient && ((_a = this.plugin.settings.oauthConfig) == null ? void 0 : _a.clientId) && ((_b = this.plugin.settings.oauthConfig) == null ? void 0 : _b.clientSecret)) {
      this.initializeClient();
    }
    if (this.confluenceClient && this.plugin.settings.tenants.length > 0) {
      const savedTenant = this.plugin.settings.tenants[0];
      if (savedTenant.oauthToken) {
        this.confluenceClient.initialize(savedTenant).catch((err) => {
          console.error("Failed to restore tenant:", err);
        });
      }
    }
    this.displayOAuthSection(containerEl);
    this.displayTenantSection(containerEl);
    this.displayConnectionStatus(containerEl);
  }
  displayOAuthSection(containerEl) {
    containerEl.createEl("h3", { text: "OAuth \uC124\uC815" });
    containerEl.createEl("p", {
      text: "Atlassian Developer Console\uC5D0\uC11C OAuth \uC571\uC744 \uB4F1\uB85D\uD558\uACE0 credentials\uB97C \uC785\uB825\uD558\uC138\uC694.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("Client ID").setDesc("OAuth \uC571\uC758 Client ID (Atlassian Developer Console\uC5D0\uC11C \uBC1C\uAE09)").addText(
      (text) => {
        var _a;
        return text.setPlaceholder("\uC608: JxHnedI71sZewJI9KjZc8ayU3YYU4aPH").setValue(((_a = this.plugin.settings.oauthConfig) == null ? void 0 : _a.clientId) || "").onChange(async (value) => {
          if (!this.plugin.settings.oauthConfig) {
            this.plugin.settings.oauthConfig = {
              clientId: value,
              clientSecret: "",
              redirectUri: "http://localhost:8080/callback",
              scope: "read:confluence-content.all write:confluence-content read:confluence-space.summary offline_access"
            };
          } else {
            this.plugin.settings.oauthConfig.clientId = value;
          }
          await this.plugin.saveSettings();
          this.initializeClient();
        });
      }
    );
    new import_obsidian2.Setting(containerEl).setName("Client Secret").setDesc("OAuth \uC571\uC758 Client Secret (\uC548\uC804\uD558\uAC8C \uC800\uC7A5\uB429\uB2C8\uB2E4)").addText((text) => {
      var _a;
      text.inputEl.type = "password";
      return text.setPlaceholder("ATOAtF9WM-zMC...").setValue(((_a = this.plugin.settings.oauthConfig) == null ? void 0 : _a.clientSecret) || "").onChange(async (value) => {
        if (!this.plugin.settings.oauthConfig) {
          this.plugin.settings.oauthConfig = {
            clientId: "",
            clientSecret: value,
            redirectUri: "http://localhost:8080/callback",
            scope: "read:confluence-content.all write:confluence-content read:confluence-space.summary offline_access"
          };
        } else {
          this.plugin.settings.oauthConfig.clientSecret = value;
        }
        await this.plugin.saveSettings();
        this.initializeClient();
      });
    });
    containerEl.createEl("details", {}, (details) => {
      details.createEl("summary", { text: "\uACE0\uAE09 \uC124\uC815" });
      new import_obsidian2.Setting(details).setName("Redirect URI").setDesc("OAuth callback\uC744 \uBC1B\uC744 URI (\uAE30\uBCF8\uAC12 \uC0AC\uC6A9 \uAD8C\uC7A5)").addText(
        (text) => {
          var _a;
          return text.setPlaceholder("http://localhost:8080/callback").setValue(((_a = this.plugin.settings.oauthConfig) == null ? void 0 : _a.redirectUri) || "http://localhost:8080/callback").onChange(async (value) => {
            if (this.plugin.settings.oauthConfig) {
              this.plugin.settings.oauthConfig.redirectUri = value;
              await this.plugin.saveSettings();
              this.initializeClient();
            }
          });
        }
      );
      new import_obsidian2.Setting(details).setName("OAuth Scope").setDesc("OAuth \uAD8C\uD55C \uBC94\uC704 (\uAE30\uBCF8\uAC12: Confluence read/write)").addTextArea(
        (text) => {
          var _a;
          return text.setPlaceholder("read:confluence-content.all write:confluence-content ...").setValue(((_a = this.plugin.settings.oauthConfig) == null ? void 0 : _a.scope) || "read:confluence-content.all write:confluence-content read:confluence-space.summary offline_access").onChange(async (value) => {
            if (this.plugin.settings.oauthConfig) {
              this.plugin.settings.oauthConfig.scope = value;
              await this.plugin.saveSettings();
              this.initializeClient();
            }
          });
        }
      );
    });
  }
  displayTenantSection(containerEl) {
    containerEl.createEl("h3", { text: "Confluence \uC5F0\uACB0" });
    new import_obsidian2.Setting(containerEl).setName("Confluence URL").setDesc("Confluence \uC778\uC2A4\uD134\uC2A4 URL (\uC608: https://yourcompany.atlassian.net)").addText(
      (text) => {
        var _a;
        return text.setPlaceholder("https://yourcompany.atlassian.net").setValue(((_a = this.plugin.settings.tenants[0]) == null ? void 0 : _a.url) || "").onChange(async (value) => {
          if (this.plugin.settings.tenants.length === 0) {
            this.plugin.settings.tenants.push({
              id: this.generateTenantId(),
              name: "Default Tenant",
              url: value,
              enabled: true
            });
          } else {
            this.plugin.settings.tenants[0].url = value;
          }
          await this.plugin.saveSettings();
        });
      }
    );
    new import_obsidian2.Setting(containerEl).setName("Confluence \uC5F0\uACB0").setDesc("OAuth \uC778\uC99D\uC744 \uC2DC\uC791\uD569\uB2C8\uB2E4 (\uBE0C\uB77C\uC6B0\uC800\uAC00 \uC5F4\uB9BD\uB2C8\uB2E4)").addButton(
      (button) => button.setButtonText("\uC5F0\uACB0").setCta().onClick(async () => {
        await this.handleConnect();
      })
    );
  }
  displayConnectionStatus(containerEl) {
    var _a, _b;
    const statusContainer = containerEl.createDiv("confluence-connection-status");
    const isConnected = ((_a = this.confluenceClient) == null ? void 0 : _a.isConnected()) || false;
    const tenant = (_b = this.confluenceClient) == null ? void 0 : _b.getCurrentTenant();
    if (isConnected && tenant) {
      statusContainer.createEl("p", {
        text: `\u2705 \uC5F0\uACB0\uB428: ${tenant.url}`,
        cls: "confluence-status-connected"
      });
    } else {
      statusContainer.createEl("p", {
        text: "\u274C \uC5F0\uACB0 \uC548 \uB428",
        cls: "confluence-status-disconnected"
      });
    }
  }
  async handleConnect() {
    var _a, _b;
    if (!((_a = this.plugin.settings.oauthConfig) == null ? void 0 : _a.clientId) || !((_b = this.plugin.settings.oauthConfig) == null ? void 0 : _b.clientSecret)) {
      new import_obsidian2.Notice("\u26A0\uFE0F OAuth Client ID\uC640 Client Secret\uC744 \uBA3C\uC800 \uC785\uB825\uD574\uC8FC\uC138\uC694.");
      return;
    }
    const tenants = this.plugin.settings.tenants;
    if (tenants.length === 0 || !tenants[0].url) {
      new import_obsidian2.Notice("\u26A0\uFE0F Confluence URL\uC744 \uBA3C\uC800 \uC785\uB825\uD574\uC8FC\uC138\uC694.");
      return;
    }
    const tenant = tenants[0];
    try {
      if (!this.confluenceClient) {
        this.initializeClient();
      }
      if (!this.confluenceClient) {
        throw new Error("Failed to initialize Confluence client");
      }
      new import_obsidian2.Notice("\u{1F504} Confluence \uC5F0\uACB0 \uC911...");
      await this.confluenceClient.initialize(tenant);
      new import_obsidian2.Notice("\u{1F504} OAuth \uC778\uC99D \uC2DC\uC791 \uC911...");
      await this.confluenceClient.initiateOAuth();
      const updatedTenant = this.confluenceClient.getCurrentTenant();
      if (updatedTenant) {
        this.plugin.settings.tenants[0] = updatedTenant;
        await this.plugin.saveSettings();
      }
      this.display();
    } catch (error) {
      if (error instanceof MCPConnectionError) {
        new import_obsidian2.Notice(`\u274C MCP Server \uC5F0\uACB0 \uC2E4\uD328

${error.message}

MCP Server\uAC00 \uC2E4\uD589 \uC911\uC778\uC9C0 \uD655\uC778\uD558\uC138\uC694.`, 1e4);
      } else if (error instanceof OAuthError) {
        new import_obsidian2.Notice(`\u274C OAuth \uC778\uC99D \uC2E4\uD328

${error.message}

\uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.`, 1e4);
      } else {
        new import_obsidian2.Notice(`\u274C \uC5F0\uACB0 \uC2E4\uD328: ${error instanceof Error ? error.message : "Unknown error"}`, 1e4);
      }
      console.error("Connection error:", error);
    }
  }
  generateTenantId() {
    return `tenant-${Date.now()}`;
  }
};

// src/types/settings.ts
var DEFAULT_SETTINGS = {
  tenants: [],
  syncPath: "confluence/",
  attachmentsPath: "attachments/",
  showNotifications: true,
  oauthConfig: {
    clientId: "",
    clientSecret: "",
    redirectUri: "http://localhost:8080/callback",
    scope: "read:confluence-content.all write:confluence-content read:confluence-space.summary offline_access"
  }
};

// main.ts
var ConfluenceSyncPlugin = class extends import_obsidian3.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
  }
  async onload() {
    console.log("Loading Confluence Sync plugin");
    await this.loadSettings();
    this.addSettingTab(new ConfluenceSettingsTab(this.app, this));
    this.addCommand({
      id: "test-confluence-sync",
      name: "Test Confluence Sync",
      callback: () => {
        new import_obsidian3.Notice("Confluence Sync plugin is working! \u{1F389}");
      }
    });
    new import_obsidian3.Notice("Confluence Sync plugin loaded successfully!");
  }
  onunload() {
    console.log("Unloading Confluence Sync plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
